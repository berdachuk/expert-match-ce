# ExpertMatch Development Rules

## Test-Driven Development (TDD) Approach

**CRITICAL**: Always follow TDD approach:
1. **Create test first** - Write the test before implementing the feature
2. **Run the test** - Verify it fails (red phase)
3. **Implement the feature** - Write minimal code to make the test pass (green phase)
4. **Refactor** - Improve code while keeping tests green
5. **Verify** - Always verify tests and implementation before switching to next task

### TDD Workflow
- Never skip writing tests
- Never implement features without tests
- Always run tests after implementation
- Fix broken tests before moving to new features
- Ensure all tests pass before marking task as complete

## Project Context

### ID Formats
- **External System Entity IDs**: Use external system format - numeric strings
  - **Employee IDs**: "8760000000000420950" (19-digit numeric string)
  - **Project IDs**: "4060741400384209073" (19-digit numeric string)
  - **Customer IDs**: "8009377469709733890" (19-digit numeric string)
  - **Entity IDs**: "8400000000019736853" (19-digit numeric string)
  - Database columns: VARCHAR(74) to accommodate external system IDs
- **Internal IDs**: Use MongoDB-compatible 24-character hexadecimal strings
  - Chat IDs, conversation IDs, work experience IDs, technology IDs
  - Database columns: CHAR(24)

### Technology Stack
- Backend: Spring Boot 3.5.9, Java 21, PostgreSQL 16, PgVector, Apache AGE, Spring AI
- Testing: JUnit 5, Testcontainers, Mockito

### Naming Conventions
- JSON/API: camelCase (`chatId`, `messageType`)
- Database: snake_case (`chat_id`, `created_at`)
- Employee IDs: Numeric strings from external system

### Development Principles
1. **API First**: OpenAPI spec drives implementation
2. **Type Safety**: Auto-generated clients from OpenAPI
3. **TDD**: Test-driven development - tests first, then implementation
4. **Modularity**: Spring Modulith (backend), component-driven (frontend)

### Planning and Implementation Strategy
- **Incremental Testable Steps**: Always propose plans with incremental, testable steps
- **Step-by-Step Improvement**: Each step should produce a working, testable state of the application
- **Testability First**: Every step must be testable before moving to the next step
- **Plan Structure**: When creating implementation plans, structure them so that:
  1. Each step builds upon the previous step
  2. Each step results in a runnable, testable application
  3. Tests can be written and executed after each step
  4. The application can be verified to work correctly at each stage
  5. Steps are small enough to be completed and tested independently
- **No Big Bang**: Avoid plans that require completing multiple features before anything is testable
- **Continuous Verification**: After each step, verify the application works and tests pass before proceeding

### Database Migrations (MVP)
- **MVP Rule**: Use only V1 migration script with all required changes consolidated
- **Single Migration**: All schema changes must be in V1__initial_schema.sql
- **No Incremental Migrations**: Do not create V2, V3, V4, etc. for MVP
- **Consolidation**: When making schema changes, update V1 directly instead of creating new migrations
- **Post-MVP**: After MVP, can use incremental migrations (V2, V3, etc.)

### Database Testing
- **Always use Testcontainers**: Never use H2 or other in-memory databases for database tests
- **PostgreSQL with Testcontainers**: All database tests must use Testcontainers with PostgreSQL
- **Real Database**: Tests should use the same database (PostgreSQL) as production to catch real issues
- **No H2**: H2 database is not compatible with PostgreSQL-specific features (PgVector, Apache AGE, etc.)
- **Integration Tests with Real Database**: Always use integration tests with real database in Testcontainers
- **Don't Mock Database Access**: Never mock database access (DataSource, JdbcTemplate, etc.) - use real database connections
- **BaseIntegrationTest**: All database-related tests should extend BaseIntegrationTest to get proper Testcontainers setup

### Custom Test Container
- **Custom Docker Image**: Project uses a custom test container image `expertmatch-postgres-test:latest`
- **Image Details**: Based on `apache/age:release_PG17_1.6.0` with PgVector 0.8.0 extension added
- **Build Script**: Use `./scripts/build-test-container.sh` or `docker build -f docker/Dockerfile.test -t expertmatch-postgres-test:latest .`
- **Image Location**: `docker/Dockerfile.test`
- **BaseIntegrationTest Configuration**: Uses `DockerImageName.parse("expertmatch-postgres-test:latest")` in static initializer
- **Container Reuse**: **ENABLED by default** (`withReuse(true)`) for faster test execution
  - Container reuse is automatically **DISABLED** when `mvn clean` is detected (target directory missing)
  - After `mvn clean`, tests get a fresh database container
  - Subsequent test runs reuse the container for faster execution
  - Configured in `BaseIntegrationTest` (checks for target directory) and `src/test/resources/testcontainers.properties`
- **Prerequisites**: Custom test container image must be built before running integration tests
- **Extensions**: Container includes PostgreSQL 17, Apache AGE 1.6.0, and PgVector 0.8.0 pre-configured
- **Important**: Always build the test container image before running tests: `./scripts/build-test-container.sh`
- **Test Independence**: `mvn clean test` always starts with a fresh database. Regular `mvn test` reuses containers for speed

## Documentation

### Documentation Location
- **Documentation Folder**: Use `/home/berdachuk/projects-ai/expert-match-root/expert-match/docs` for all documentation files
- **Documentation Types**: API guides, setup instructions, Postman collections, authorization guides, etc.
- **Build Exclusion**: The `docs` folder is excluded from build targets and should not be included in JAR/WAR files

## Code Quality
- Write clean, maintainable code
- Follow SOLID principles
- Use meaningful variable and method names
- Add comments for complex logic
- Keep methods small and focused

### Logging
- **Use Lombok Logging**: Always use Lombok's `@Slf4j` annotation for logging
- **Never use static logger declarations**: Do not use `private static final Logger logger = LoggerFactory.getLogger(ClassName.class);`
- **Lombok Pattern**: Use `@Slf4j` annotation on the class, which automatically provides a `log` field
- **Example**:
  ```java
  @Slf4j
  @Service
  public class MyService {
      public void doSomething() {
          log.info("Doing something");
      }
  }
  ```
- **Benefits**: Reduces boilerplate, consistent logging pattern across the codebase

### Imports and Class Names
- **Use Imports Instead of Fully Qualified Names**: Never use fully qualified class names when imports can be used
- **Invalid**: `java.io.File`, `java.util.List`, `java.time.Duration`
- **Valid**: `File` (with `import java.io.File;`), `List` (with `import java.util.List;`), `Duration` (with `import java.time.Duration;`)
- **Exception**: Only use fully qualified names when there's a naming conflict that requires disambiguation
- **Benefits**: Cleaner, more readable code; standard Java practice

### Error Handling
- **Never Add Fallbacks**: Do not implement fallback mechanisms that silently handle errors
- **Fail Fast**: When operations fail, throw exceptions instead of falling back to alternative behavior
- **Explicit Error Handling**: All errors should be explicitly handled and reported, not hidden by fallback logic
- **Invalid**: Catching exceptions and using fallback values, alternative parsing methods, or default behaviors
- **Valid**: Throwing exceptions, returning error responses, or logging errors and failing
- **Benefits**: Makes errors visible, prevents silent failures, improves debugging and reliability

### Transaction Management
- **Service-Level Transactions**: Always manage transactions at the service layer, not at the repository or controller layer
- **Use @Transactional**: Use Spring's `@Transactional` annotation on service methods that perform database operations
- **Transaction Boundaries**: Define transaction boundaries at service methods that represent business operations
- **Invalid**: `@Transactional` on repository methods, controller methods, or private methods
- **Valid**: `@Transactional` on public service methods that orchestrate multiple repository calls
- **Propagation**: Use default `REQUIRED` propagation for most cases; use `REQUIRES_NEW` only when isolation is needed (e.g., checking graph existence without aborting main transaction)
- **Read-Only Transactions**: Use `readOnly = true` for read-only operations to optimize performance
- **Example**:
  ```java
  @Service
  public class MyService {
      private final MyRepository repository;
      
      @Transactional
      public void performBusinessOperation(String id) {
          // Multiple repository calls in one transaction
          repository.update(id);
          repository.log(id);
          // All operations succeed or all rollback
      }
      
      @Transactional(readOnly = true)
      public MyEntity findById(String id) {
          return repository.findById(id);
      }
      
      @Transactional(propagation = Propagation.REQUIRES_NEW, readOnly = true)
      public boolean checkStatus() {
          // Separate transaction to avoid aborting main transaction
          return repository.checkStatus();
      }
  }
  ```
- **Benefits**: Clear transaction boundaries, atomic business operations, proper error handling and rollback, better performance with read-only transactions

### Repository Design - Single Entity Principle
- **Single Entity Focus**: Repositories should always work with one entity type. Each repository method should operate on a single entity or collection of the same entity type
- **Related Data Loading**: If related entity data needs to be loaded, prefer doing it in a single SQL query with JOINs and proper mapping
- **Service-Level Aggregation**: If related data cannot be loaded in a single SQL query, the aggregation should happen at the service layer, not in the repository
- **Invalid**: Loading related entities in repository methods (e.g., `loadSkills()`, `loadProjects()` methods that modify entities after query)
- **Valid**: Single SQL query with JOINs that returns all needed data, then mapping in repository
- **Valid**: Service layer orchestrating multiple repository calls to aggregate related data
- **Example - Invalid**:
  ```java
  @Repository
  public class EmployeeRepository {
      public List<Employee> findAll() {
          List<Employee> employees = namedJdbcTemplate.query(findAllSql, employeeMapper);
          // Invalid: Loading related data in repository
          employees.forEach(this::loadSkills);
          return employees;
      }
      
      private void loadSkills(Employee employee) {
          // This should be in service layer
          List<String> skills = namedJdbcTemplate.query(loadSkillsSql, ...);
          employee.setSkills(skills);
      }
  }
  ```
- **Example - Valid (Single Query)**:
  ```java
  @Repository
  public class EmployeeRepository {
      public List<Employee> findAll() {
          // Single SQL query with JOIN to get skills
          return namedJdbcTemplate.query(findAllWithSkillsSql, employeeWithSkillsMapper);
      }
  }
  ```
- **Example - Valid (Service Layer with Batch Loading)**:
  ```java
  @Service
  public class EmployeeService {
      private final EmployeeRepository employeeRepository;
      private final SkillRepository skillRepository;
      
      @Transactional(readOnly = true)
      public List<Employee> findAll() {
          List<Employee> employees = employeeRepository.findAll();
          // Batch load all skills for all employees in one query
          List<String> employeeIds = employees.stream().map(Employee::getId).toList();
          Map<String, List<String>> skillsByEmployeeId = skillRepository.findByEmployeeIds(employeeIds);
          // Map skills to employees
          employees.forEach(emp -> {
              List<String> skills = skillsByEmployeeId.getOrDefault(emp.getId(), List.of());
              emp.setSkills(skills);
          });
          return employees;
      }
  }
  ```
- **Batch Loading Requirement**: When loading related data for a collection of entities, always use batch loading methods that accept a collection of IDs and return a Map. This prevents N+1 query problems.
- **Invalid**: Loading related data in a loop (N+1 queries):
  ```java
  employees.forEach(emp -> {
      List<String> skills = skillRepository.findByEmployeeId(emp.getId()); // N+1 queries!
      emp.setSkills(skills);
  });
  ```
- **Valid**: Batch loading with single query:
  ```java
  List<String> employeeIds = employees.stream().map(Employee::getId).toList();
  Map<String, List<String>> skillsByEmployeeId = skillRepository.findByEmployeeIds(employeeIds); // Single query
  employees.forEach(emp -> {
      List<String> skills = skillsByEmployeeId.getOrDefault(emp.getId(), List.of());
      emp.setSkills(skills);
  });
  ```
- **Repository Batch Methods**: Repositories should provide batch loading methods like `findByEntityIds(List<String> ids)` that return `Map<String, List<RelatedEntity>>` for efficient data loading
- **Benefits**: Clear separation of concerns, repositories focus on single entity operations, services handle business logic and aggregation, prevents N+1 query problems, better performance, easier to test and maintain

### Prompt Management
- **Always Use PromptTemplates and .st Resources**: All LLM prompts must use Spring AI `PromptTemplate` with external `.st` (StringTemplate) files
- **Template Location**: Store all prompt templates in `src/main/resources/prompts/` directory
- **Template Format**: Use `.st` file extension for StringTemplate files
- **Configuration**: Define `PromptTemplate` beans in `PromptTemplateConfig` with `@Qualifier` annotations
- **Invalid**: Hardcoded prompt strings, `StringBuilder`-based prompt construction, inline prompt text in Java code
- **Valid**: External `.st` files with `PromptTemplate` beans injected via constructor
- **Example**:
  ```java
  // Template file: src/main/resources/prompts/my-prompt.st
  // Configuration: PromptTemplateConfig.java
  @Bean
  @Qualifier("myPromptTemplate")
  public PromptTemplate myPromptTemplate(StTemplateRenderer stTemplateRenderer) {
      return PromptTemplate.builder()
              .renderer(stTemplateRenderer)
              .templateResource(new ClassPathResource("/prompts/my-prompt.st"))
              .build();
  }

  // Usage in service
  private final PromptTemplate myPromptTemplate;

  public MyService(@Qualifier("myPromptTemplate") PromptTemplate myPromptTemplate) {
      this.myPromptTemplate = myPromptTemplate;
  }

  private String buildPrompt(String variable) {
      Map<String, Object> variables = new HashMap<>();
      variables.put("variable", variable);
      return myPromptTemplate.render(variables);
  }
  ```
- **Benefits**: Centralized prompt management, easier to update prompts without code changes, better separation of concerns, version control for prompts

### Code Language
- **Always Use English**: All code, comments, project files, README, documentation, and technical content must be in English
- **Code Comments**: All code comments must be in English
- **Variable/Method Names**: All variable and method names must be in English
- **Project Files**: All project files (README.md, CHANGELOG.md, etc.) must be in English
- **Documentation**: All technical documentation must be in English
- **Exception**: User-facing messages in the application can be localized, but code and technical content must remain in English
- **Benefits**: International collaboration, standard practice, better code readability, easier maintenance
